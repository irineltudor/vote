# -*- coding: utf-8 -*-
"""vote.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EBF0S8P1ykFRChiRWnGfqbRBum5r0lCf

# Pip Install
"""

pip cache purge

pip install google-cloud-firestore

pip install firebase_admin

pip install --upgrade firebase-admin google-cloud-firestore

pip install web3

pip install py-solc-x

pip install google-cloud-secret-manager

pip install firebase-admin==5.2.0 google-cloud-firestore==2.9.0

pip install cryptography

"""# Import"""

import firebase_admin
from firebase_admin import credentials
from firebase_admin import firestore
import time
import datetime
import json
import solcx
from solcx import compile_standard
from solcx import compile_source
from web3 import  Web3, exceptions
from eth_account import Account

from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
import base64

from google.colab import drive
drive.mount('/content/gdrive/')

"""# Consts"""

root_directory_path = "/content/gdrive/MyDrive/vote/"

"""# User Defined Functions"""

def readJsonFile(path):
  f = open(path,'r')

  data = json.load(f)

  f.close()

  return data

def generate_wallets(number_of_wallets):
    wallets = []
    for _ in range(number_of_wallets):
        account = Account.create()
        wallet = {
            'address': account.address,
            'private_key': account.key.hex()
        }
        wallets.append(wallet)
    return wallets

def addElectionToDb(election):
  doc_ref = db.collection('election').document()
  doc_ref.set(election)

def deploy_election_contract(election, constructor_args):

    nonce = web3.eth.get_transaction_count(address)

    transaction = election.constructor(*constructor_args).build_transaction({
        'from': address,
        'nonce': nonce,
        # 'gasPrice' : web3.to_wei('10', 'gwei'),
        'chainId': 11155111
    })

    # Estimate the gas
    gas_estimate = web3.eth.estimate_gas(transaction)
    gas_price = web3.eth.gas_price
    estimate_wei = gas_price *gas_estimate
    estimate_eth = web3.from_wei(estimate_wei, 'ether')

    gas_limit = gas_estimate + 100000

    print(f'Estimated Gas: {gas_estimate}')
    print(f'Estimated Price for transaction in eth: {estimate_eth}')


    if(estimate_eth > 0.15 ):
      print(f'TOO MUCH COSTS')
      return ""
    else:
      transaction.update({'gas': gas_limit})

      # Sign the transaction
      signed_txn = web3.eth.account.sign_transaction(transaction, private_key=private_key)

      # Send the signed transaction
      tx_hash = web3.eth.send_raw_transaction(signed_txn.rawTransaction)

      # Wait for the transaction to be mined
      tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)

      contract_address = tx_receipt.contractAddress
      print(f'Contract for "{constructor_args[0]}" deployed at address: {contract_address}')
      return contract_address

def send_eth(recipient_address, amount):

  nonce = web3.eth.get_transaction_count(address)

  # Build the transaction
  transaction = {
    'to': recipient_address,
    'value': amount,
    'gas': 21000,
    'nonce': nonce,
    'gasPrice': web3.to_wei('10', 'gwei'),
    'nonce': web3.eth.get_transaction_count(address),
    'chainId': 11155111  # Sepolia chain ID
  }

  # Sign the transaction
  signed_txn = web3.eth.account.sign_transaction(transaction, private_key)

  # Send the transaction
  txn_hash = web3.eth.send_raw_transaction(signed_txn.rawTransaction)

  # Get the transaction hash
  print(f'Transaction hash: {txn_hash.hex()}')

  # Wait for the transaction to be mined
  txn_receipt = web3.eth.wait_for_transaction_receipt(txn_hash)
  print(f'Transaction receipt: {txn_receipt}')

"""# Initializing Firebase"""

cred = credentials.Certificate(root_directory_path + "vote-db-cbc06-firebase-adminsdk-8nw48-d625e9b60d.json")
firebase_admin.initialize_app(cred)

db = firebase_admin.firestore.client()

"""#Getting arguments for contract constructor"""

election_path = root_directory_path +  'Elections.json'
person_path = root_directory_path + 'Person-Wallet.json'

person_json = readJsonFile(person_path)

person_data = person_json['person_wallet']

person_address_list = []

for person in person_data:
  person_address = []
  person_address.append(person['cnp'][7:9])
  person_address.append(person['address'])
  person_address_list.append(person_address)


print(person_address_list)

election_json = readJsonFile(election_path)
election_data = election_json['elections']
print(election_data)

election_contract_args_list = []
for election in election_data:
  eligible_address = []
  county_code = 'none'
  if('electionCountyCode' in election):
    county_code = election['electionCountyCode']

  for person_address in person_address_list:
    if(county_code == 'none'):
      eligible_address.append(person_address[1])
    else:
      if(county_code == '4X' and person_address[0][0] == '4'):
        eligible_address.append(person_address[1])
      else:
        if(county_code == person_address[0]):
          eligible_address.append(person_address[1])

  candidates = []
  about = []
  for candidate in election['candidates']:
    candidates.append(candidate['name'])
    about.append(candidate['about'])


  candidates.append('VOT ALB')
  about.append('VOT NUL')

  start_date = election['start_date']
  end_date = election['end_date']

  start_date = datetime.datetime.strptime(election['start_date'],"%m-%d-%Y")
  end_date = datetime.datetime.strptime(election['end_date'],"%m-%d-%Y")

  start_date_timestamp = datetime.datetime.timestamp(start_date)
  end_date_timestamp = datetime.datetime.timestamp(start_date) + 86400

  start_date_timestamp_GMT = int(start_date_timestamp - 10800)
  end_date_timestamp_GMT = int(end_date_timestamp - 10800)

  duration = end_date_timestamp_GMT - start_date_timestamp_GMT

  election_contract_args = (election['electionName'],election['electionCountry'],candidates,about,eligible_address,start_date_timestamp_GMT,duration)
  election_contract_args_list.append(election_contract_args)

print(election_contract_args_list[8])

"""#Web 3 initialization"""

provider_url = 'https://sepolia.infura.io/v3/12b4a44ec28a41f892d243770ac30351';

# Connect to a local Ethereum node
web3 = Web3(Web3.HTTPProvider(provider_url))

# Check if connected
web3

"""#Build Smart contract"""

solcx.install_solc(version='latest')

contract_path = root_directory_path + 'ElectionFinal.sol'

with open(contract_path, 'r') as file:
  contract_file = file.read()

compiled_sol = compile_source(contract_file,output_values = ['abi','bin'])

contract_id, contract_interface = compiled_sol.popitem()

bytecode = contract_interface['bin']

abi = contract_interface['abi']

"""#Deploy Smart Contract"""

address = "0x750FEbc563E5441eD92B0bBd9F2702561Ea8c582"
private_key = "780b8c55e79f14ccfe8c6db84ff192c94f0585e854abe196cceb096f63a29395"

account = web3.eth.account.from_key(private_key)

web3.eth.default_account = account.address

Election = web3.eth.contract(abi=abi, bytecode=bytecode)

index = 8
election_contract_args_list[index]

constructor_args = election_contract_args_list[index]

contract_address = deploy_election_contract(Election, constructor_args)

if(contract_address != ""):
  election = {
    'contractAddress' : contract_address,
    'img' : '',
    'testContract' : False
  }

  addElectionToDb(election)

latest_block = web3.eth.get_block('latest')
base_fee = latest_block['baseFeePerGas']
print(base_fee)
max_priority_fee_per_gas = web3.to_wei(2, 'gwei')  # Set priority fee
max_fee_per_gas = base_fee + max_priority_fee_per_gas * 2  # Set max fee
print(max_fee_per_gas)

"""Aproximate Gas Price for voting"""

contract = web3.eth.contract(address="0x11D38C74b3702a197B3e03A5798701443852004F", abi=abi)

vote = contract.functions.vote(0)


estimated_gas = vote.estimate_gas({'from': '0x6c861e635cD16c31624A7038308c97c78f97a28b'})

print(estimated_gas)
print(f'Estimated Gas: {estimated_gas}')


gas_price = web3.eth.gas_price
print(f'Current Gas Price (Wei): {gas_price}')


cost_in_wei = estimated_gas * gas_price
cost_in_eth = web3.from_wei(cost_in_wei, 'ether')
print(f'Estimated Cost (ETH): {cost_in_eth}')

"""Send for each eligible address"""

buf = 10000
amount = cost_in_wei + buf * gas_price

for voter in constructor_args[4]:
  send_eth(voter, amount)

"""# Private key creation, saving data to firestore db"""

num_wallets = 10

wallets = generate_wallets(num_wallets)

print(wallets)

with open('Person-Wallet.json', 'w') as f:
    json.dump(wallets, f, indent=2)

wallet_path = root_directory_path + 'Person-Wallet.json'

wallet_data = readJsonFile(wallet_path)

wallet_collection = db.collection('wallet')

keys = {}

for i in wallet_data['person_wallet']:
  wallet_address = i['address']
  wallet_private_key = i['private_key']
  wallet_owner = i['cnp']

  # Generate RSA keys
  private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
  )

  public_key = private_key.public_key()


  # Serialize private key
  private_key_pem = private_key.private_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PrivateFormat.TraditionalOpenSSL,
    encryption_algorithm=serialization.NoEncryption()
  ).decode('utf-8')



  wallet_private_key_enc = public_key.encrypt(
    wallet_private_key.encode(),
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
    )
  )

  wallet_owner_enc = public_key.encrypt(
    wallet_owner.encode(),
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
    )
  )

  wallet_address_enc = public_key.encrypt(
    wallet_address.encode(),
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
    )
  )

  wallet_private_key_enc_base64 = base64.b64encode(wallet_private_key_enc).decode('utf-8')
  wallet_owner_enc_base64 = base64.b64encode(wallet_owner_enc).decode('utf-8')
  wallet_address_enc_base64 = base64.b64encode(wallet_address_enc).decode('utf-8')

  wallet = {
      "owner" : wallet_owner_enc_base64,
      "address" : wallet_address_enc_base64,
      "privateKey" :  wallet_private_key_enc_base64
  }

  wallet_ref =  wallet_collection.document()

  wallet_ref.set(wallet)

  d = {
      wallet_owner : {
          "document_id" : wallet_ref.id,
          "private_key" : private_key_pem
      }
  }

  keys.update(d)


fernet_key = Fernet.generate_key()
secret = {
    "fernet_key" : fernet_key.decode("utf-8"),
    "wallet_keys" : keys
}


with open('secret.json', 'w') as f:
    json.dump(secret, f, indent = len(wallet_data['person_wallet']) * 2 + 1)

print("Secret saved to secret.json")